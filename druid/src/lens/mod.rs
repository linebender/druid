// Copyright 2020 the Druid Authors
// SPDX-License-Identifier: Apache-2.0

//! Implementations of [`Lens`], a way of focusing on subfields of data.
//!
//! Lenses are useful whenever a widget only needs access to a subfield of a larger struct or
//! generally access to part of a larger value.
//!
//! For example: If one wants to embed a [`TextBox`](crate::widget::TextBox) in a widget with
//! a `Data` type that is not `String`, they need to specify how to access a `String` from
//! within the `Data`.
//!
//! ```
//! use druid::{Data, Lens, Widget, WidgetExt, widget::{TextBox, Flex}};
//!
//! #[derive(Clone, Debug, Data, Lens)]
//! struct MyState {
//!     search_term: String,
//!     scale: f64,
//!     // ...
//! }
//!
//!
//! fn my_sidebar() -> impl Widget<MyState> {
//!     // `TextBox` is of type `Widget<String>`
//!     // via `.lens` we get it to be of type `Widget<MyState>`.
//!     // `MyState::search_term` is a lens generated by the `derive(Lens)` macro,
//!     // that provides access to the search_term field.
//!     let searchbar = TextBox::new().lens(MyState::search_term);
//!
//!     // ...
//!
//!     // We can now use `searchbar` just like any other `Widget<MyState>`
//!     Flex::column().with_child(searchbar)
//! }
//! ```
//!
//! Most of the time, if you want to create your own lenses, you need to use
//! [`#[derive(Lens)]`](druid_derive::Lens).

#[allow(clippy::module_inception)]
#[macro_use]
mod lens;
pub use lens::{
    Constant, Deref, Field, Identity, InArc, Index, Lens, LensExt, Map, Ref, Then, Unit,
};
